Document: 2. Class Declaration

The BlazeGears class declaration interface is largely based on the concepts used by the Python language. It supports constructors, self-references, singletons, regular and multiple inheritance, superclass searching, and static members.

See Also:
	<BlazeGears.Classes>


Topic: Declaring a Class

The class declaring method handles arguments dynamically. The last argument must a dictionary, this will be the declaration, and all the prior ones will be the superclasses of the class.

The example below will show the usage of constructors and self-references.

(code)
	MyClass = BlazeGears.Classes.declareClass({
		my_property: null, // property
		
		// the constructor, sets the value of the property
		__init__: function(self, my_argument) {
			self.my_property = my_argument;
		},
		
		// tells the value of the property
		myMethod: function(self) { // method
			alert(self.my_property);
		}
	});
	
	my_obj = MyClass("I'm a class!");
	my_obj.myMethod(); // I'm a class!
(end)

The constructor method of the class is a magical member and will be called each time an instance of the class is created. Magical members can be recognized from the double underscores surrounding their names.

Self-references are meant to replace the *this* keyword, because its' value might change depending on the context where the method's called from. When a method is called, the self-reference will be pushed in the front of its' argument list by a wrapper. These arguments called "self" in all the standard BlazeGears methods.


Topic: Singletons

Singletons work almost the same as regular classes do, but upon trying to create a second instance, the reference to the for the first instance will be returned instead.

(code)
	MySingleton = BlazeGears.Classes.declareSingleton({
		my_property: "I'm a class!"
	});
	
	my_obj_1 = MySingleton();
	my_obj_2 = MySingleton();
	my_obj_1.my_property = "I'm a singleton!";
	alert(my_obj_2.my_property); // I'm a singleton!
(end)


Topic: Regular and Multiple Inheritance

Besides regular inheritance, BlazeGears also supports multiple inheritance. For multiple inheritance the list of superclasses must be provided in an order of descending priority. In case there are multiple members of the same name inherited from different superclasses, the one with the highest priority will be used.

There's a magical method available to all instances, called "super", which will search the superclasses in order of priority for a method, and calls it if it's available.

(code)
	Canine = BlazeGears.Classes.declareClass({
		__init__: function(self, name) {
			self.name = name;
		},
		
		bark: function(self) {
			alert("Aroo!");
		},
		
		greet: function(self) {
			alert("Hey! My name's " + self.name + "!");
		}
	});
	
	Fox = BlazeGears.Classes.declareClass(Canine, { // regular inheritance
		greet: function(self) {
			alert("Hi there! I'm a fox!");
		}
	});
	
	Dog = BlazeGears.Classes.declareClass({
		bark: function(self) {
			alert("Woof!");
		}
	});
	
	Hellhound = BlazeGears.Classes.declareClass(Dog, Canine, { // multiple inheritance
		__init__: function(self, name, type) {
			self.__super__("__init__", name); // calling the super's constructor
			self.bark();
		}
	});
	
	foxy = new Fox("Foxy");
	foxy.greet(); // Hi there! I'm a fox!
	cerb = new Hellhound("Cerberus"); // Woof!
	cerb.greet(); // Hey! My name's Cerberus!
(end)


Topic: Static Members

To make a member static the dollar sign prefix must be used. In the case of static methods the self-references will point to the class itself instead of the instance. The same reference is also available for the regular methods through the use of a magical property, called "class".

(code)
	MyClass = BlazeGears.Classes.declareClass({
		$my_static_property: 5, // static property
		
		// calls the static method and tells the value of the static property
		myMethod: function(self) {
			self.myStaticMethod()
			alert(self.__class__.my_static_property);
		},
		
		// increases the static propertie's value by one
		$myStaticMethod: function(class_reference, my_argument) {
			class_reference.my_static_property++;
		}
	});
	
	alert(MyClass.my_static_property); // 5
	MyClass.myStaticMethod();
	alert(MyClass.my_static_property); // 6
	my_obj = new MyClass();
	my_obj.myMethod(); // 7
	my_obj.myMethod(); // 8
(end)
